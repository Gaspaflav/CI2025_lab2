"""
Genetic Algorithm for the Travelling Salesman Problem (TSP)

Key improvements compared to the original notebook:

1. PERFORMANCE:
   - Precompute a distance matrix once per problem.

2. GENETIC OPERATORS:
   - Keep swap mutation.
   - Add inversion mutation (better for TSP adjacency preservation).

3. LOCAL SEARCH:
   - Add a light 2-opt local search applied to some good individuals
     (memetic algorithm-style improvement).

4. POPULATION MANAGEMENT:
   - Use tournament selection.
   - Use explicit elitism (best individual always survives).

5. REPRODUCIBILITY:
   - Fixed random seeds for consistent experiments.
"""

from itertools import combinations
import numpy as np
import random
import time as time
import matplotlib.pyplot as plt


"""
Set random seeds for reproducibility.
If you want different runs, you can change these numbers.
"""
random.seed(42)
np.random.seed(42)

def compute_distance_matrix(problem: np.ndarray) -> np.ndarray:
    """
    Precompute the pairwise distance matrix between all cities.

    'problem' is an (n, 2) array where each row is the (x, y) coordinate
    of a city.

    We compute and store all distances in a matrix 'D' such that
    D[i, j] is the distance between city i and city j.

    This allows us to evaluate tour lengths much faster because each
    distance lookup becomes O(1) instead of recomputing sqrt(...) every time.
    """
    n = problem.shape[0]
    D = np.zeros((n, n), dtype=float)
    for i in range(n):
        for j in range(i + 1, n):
            dx = problem[i, 0] - problem[j, 0]
            dy = problem[i, 1] - problem[j, 1]
            dist = (dx * dx + dy * dy) ** 0.5
            D[i, j] = dist
            D[j, i] = dist
    return D


def tour_length(tour, dist_matrix: np.ndarray) -> float:
    """
    Compute the total length of a tour using the precomputed distance matrix.

    'tour' is a permutation of city indices, e.g. [0, 3, 1, 2].
    We close the tour by returning to the first city.
    """
    length = 0.0
    for i in range(len(tour)):
        a = tour[i]
        b = tour[(i + 1) % len(tour)]
        length += dist_matrix[a, b]
    return length

def greedy_initial_solution(problem: np.ndarray) -> list:
    """
    Construct a greedy tour starting from city 0.

    At each step, go to the nearest unvisited city.

    This is used to seed the initial population with a reasonably good
    solution so that the GA does not start purely from random tours.
    """
    n = problem.shape[0]
    unvisited = set(range(n))
    current_city = 0
    tour = [current_city]
    unvisited.remove(current_city)

    while unvisited:
        # Choose the nearest unvisited city
        next_city = min(
            unvisited,
            key=lambda city: np.linalg.norm(problem[current_city] - problem[city])
        )
        tour.append(next_city)
        unvisited.remove(next_city)
        current_city = next_city

    return tour

def initialize_population(problem: np.ndarray,
                          dist_matrix: np.ndarray,
                          population_size: int,
                          greedy_fraction: float = 0.2):
    """
    Initialize the population of tours.

    - A fraction 'greedy_fraction' of the population is generated by
      starting from the greedy tour and shuffling it slightly.
    - The remaining tours are completely random permutations.

    This combines heuristic knowledge (greedy) with diversity (random).
    """
    n = problem.shape[0]
    population = []

    num_greedy = int(population_size * greedy_fraction)
    greedy_tour = greedy_initial_solution(problem)

    # Greedy-based tours
    for _ in range(num_greedy):
        tour = greedy_tour.copy()
        random.shuffle(tour)
        population.append(tour)

    # Pure random tours
    while len(population) < population_size:
        tour = list(range(n))
        random.shuffle(tour)
        population.append(tour)

    # Compute fitness values
    fitness = [tour_length(t, dist_matrix) for t in population]
    return population, fitness

def tournament_selection(population, fitness, k: int = 3):
    """
    Tournament selection:

    1. Randomly sample 'k' individuals from the population.
    2. Return the one with the best (lowest) fitness.

    This balances exploration and exploitation and is easy to implement.
    """
    selected_indices = random.sample(range(len(population)), k)
    best_idx = min(selected_indices, key=lambda idx: fitness[idx])
    return population[best_idx]


def pmx_crossover(parent1, parent2):
    """
    Partially Mapped Crossover (PMX) for permutations.

    PMX works as follows:
    - Choose two cut points.
    - Swap the corresponding segment between parents.
    - Resolve conflicts by mapping values according to the swapped segments.

    This operator preserves relative order and position information,
    which is useful for TSP.
    """
    n = len(parent1)
    c1, c2 = sorted(random.sample(range(n), 2))

    child = [None] * n

    # Copy slice from parent1
    child[c1:c2] = parent1[c1:c2]

    # Map the remaining positions from parent2
    for i in range(c1, c2):
        value = parent2[i]
        if value not in child:
            pos = i
            while True:
                mapped_value = parent1[pos]
                pos = parent2.index(mapped_value)
                if child[pos] is None:
                    child[pos] = value
                    break

    # Fill any remaining spots with values from parent2
    for i in range(n):
        if child[i] is None:
            child[i] = parent2[i]

    return child


def swap_mutation(tour):
    """
    Swap mutation:

    - Choose two positions at random and swap their cities.

    This is a simple way to introduce small changes in the tour.
    """
    a, b = random.sample(range(len(tour)), 2)
    tour[a], tour[b] = tour[b], tour[a]
    return tour


def inversion_mutation(tour):
    """
    Inversion mutation:

    - Choose two indices a < b.
    - Reverse the subsequence between them.

    This is especially suitable for TSP because it preserves most of
    the tour while potentially improving local segments.
    """
    a, b = sorted(random.sample(range(len(tour)), 2))
    tour[a:b] = reversed(tour[a:b])
    return tour


def two_opt(tour, dist_matrix, max_swaps: int = 50):
    """
    Simple 2-opt local search:

    - Try swapping two edges at a time and keep the change if it improves
      the tour length.
    - Stop after 'max_swaps' successful improvements or when no better move
      is found.

    We only apply this to some of the best individuals in each generation
    to limit the computational cost.
    """
    best_tour = tour.copy()
    best_length = tour_length(best_tour, dist_matrix)
    n = len(tour)
    swaps_done = 0

    improved = True
    while improved and swaps_done < max_swaps:
        improved = False
        for i in range(n - 1):
            for j in range(i + 2, n):
                if j == n - 1 and i == 0:
                    # Avoid breaking the tour in a trivial way
                    continue
                # Calculate the cost difference if we reverse segment [i+1:j]
                a, b = best_tour[i], best_tour[i + 1]
                c, d = best_tour[j], best_tour[(j + 1) % n]

                current_edges = dist_matrix[a, b] + dist_matrix[c, d]
                new_edges = dist_matrix[a, c] + dist_matrix[b, d]

                if new_edges < current_edges:
                    # Perform the 2-opt move
                    best_tour[i + 1:j + 1] = reversed(best_tour[i + 1:j + 1])
                    best_length = tour_length(best_tour, dist_matrix)
                    improved = True
                    swaps_done += 1
                    break
            if improved or swaps_done >= max_swaps:
                break

    return best_tour


def genetic_algorithm(problem: np.ndarray,
                      population_size: int = 100,
                      generations: int = 500,
                      greedy_fraction: float = 0.2,
                      crossover_prob: float = 0.9,
                      swap_mut_prob: float = 0.2,
                      invert_mut_prob: float = 0.4,
                      tournament_k: int = 3,
                      local_search_fraction: float = 0.1,
                      no_improve_limit: int = 100):
    """
    Main GA loop for TSP.

    Parameters (key ones):

    - population_size: number of individuals.
    - generations: maximum number of generations to run.
    - greedy_fraction: fraction of initial population generated from
      greedy tours (the rest is random).
    - crossover_prob: probability to apply crossover when creating a child.
    - swap_mut_prob: probability to apply swap mutation.
    - invert_mut_prob: probability to apply inversion mutation.
    - tournament_k: tournament size for selection.
    - local_search_fraction: fraction of best individuals to improve via 2-opt.
    - no_improve_limit: stop early if we see no improvement for this many generations.

    The function returns the best length found and the associated tour.
    """
    n = problem.shape[0]

    # Precompute distance matrix for performance.
    dist_matrix = compute_distance_matrix(problem)

    # Initialize population
    population, fitness = initialize_population(
        problem, dist_matrix, population_size, greedy_fraction
    )

    # Track global best solution
    best_idx = int(np.argmin(fitness))
    best_tour = population[best_idx].copy()
    best_length = fitness[best_idx]

    no_improve_counter = 0

    best_history = []

    for gen in range(generations):
        new_population = []

        """
        Elitism:
        - Always keep the best individual found so far.
        """
        new_population.append(best_tour.copy())

        # Create the rest of the new population
        while len(new_population) < population_size:
            parent1 = tournament_selection(population, fitness, k=tournament_k)
            parent2 = tournament_selection(population, fitness, k=tournament_k)

            # Crossover
            if random.random() < crossover_prob:
                child = pmx_crossover(parent1, parent2)
            else:
                child = parent1.copy()

            # Mutations
            if random.random() < swap_mut_prob:
                child = swap_mutation(child)

            if random.random() < invert_mut_prob:
                child = inversion_mutation(child)

            new_population.append(child)

        population = new_population
        fitness = [tour_length(t, dist_matrix) for t in population]

        """
        Local search:
        - Apply 2-opt to a fraction of the best individuals in the current generation.
        - This turns the algorithm into a "memetic" GA (GA + local improvement).
        """
        num_ls = max(1, int(population_size * local_search_fraction))
        # Indices of individuals sorted by fitness (ascending = best first)
        sorted_indices = sorted(range(population_size), key=lambda i: fitness[i])

        for idx in sorted_indices[:num_ls]:
            improved_tour = two_opt(population[idx], dist_matrix, max_swaps=20)
            improved_length = tour_length(improved_tour, dist_matrix)
            if improved_length < fitness[idx]:
                population[idx] = improved_tour
                fitness[idx] = improved_length

        # Update global best
        gen_best_idx = int(np.argmin(fitness))
        gen_best_length = fitness[gen_best_idx]

        if gen_best_length < best_length:
            best_length = gen_best_length
            best_tour = population[gen_best_idx].copy()
            no_improve_counter = 0
        else:
            no_improve_counter += 1

        best_history.append(best_length)

        # Early stopping if no improvement for a while
        if no_improve_counter >= no_improve_limit:
            break

    return best_length, best_tour, best_history


def plot_tour(problem: np.ndarray, tour, title: str = "TSP Tour"):
    """
    Plot a given tour on a 2D plane using matplotlib.
    """
    coords = problem[tour + [tour[0]]]  # close the tour
    x, y = coords[:, 0], coords[:, 1]

    plt.figure(figsize=(6, 6))
    plt.plot(x, y, marker='o')
    plt.title(title)
    plt.xlabel("x")
    plt.ylabel("y")
    plt.grid(True)
    plt.show()


"""
In the original notebook, you loop over several problem instances
with different sizes and adjust population/generations accordingly.

Below is a cleaner and commented version of that loop. You will need
to adjust the file paths to match your environment.

If your files are named like:
    problem_r2_10.npy, problem_r2_20.npy, ..., etc.

You can load them from a folder (e.g., "lab2") as shown below.
"""

# Example file list (adapt paths to your setup)
problem_files = [
    "lab2/problem_r2_10.npy",
    "lab2/problem_r2_20.npy",
    "lab2/problem_r2_50.npy",
    "lab2/problem_r2_100.npy",
    "lab2/problem_r2_200.npy",
    "lab2/problem_r2_500.npy",
    "lab2/problem_r2_1000.npy",
]

"""
Strategy:
- Start from a base population size and number of generations.
- Increase them as the problem size grows.
"""

base_pop_size = 50
base_generations = 200

for file_path in problem_files:
    try:
        problem = np.load(file_path)
    except FileNotFoundError:
        print(f"File not found: {file_path} (skip)")
        continue

    n_cities = problem.shape[0]

    # Simple scaling strategy: larger instances get more resources.
    pop_size = max(base_pop_size, int(0.2 * n_cities))
    generations = max(base_generations, int(3 * n_cities))

    time_start = time.time()

    best_length, best_tour, history = genetic_algorithm(
        problem,
        population_size=pop_size,
        generations=generations,
        greedy_fraction=0.3,
        crossover_prob=0.9,
        swap_mut_prob=0.2,
        invert_mut_prob=0.4,
        tournament_k=3,
        local_search_fraction=0.1,
        no_improve_limit=int(0.3 * generations),
    )

    time_end = time.time()

    print(
        f"Problem: {file_path}, Cities: {n_cities}, "
        f"Best length: {best_length:.3f}, "
        f"Time: {time_end - time_start:.2f} s"
    )

    # Optional: plot final tour for smaller instances
    if n_cities <= 100:
        plot_tour(problem, best_tour, title=f"TSP tour ({n_cities} cities)")
